# Front-End
### 前端开发工程师面试宝典！           [![AppVeyor](https://img.shields.io/badge/%E6%89%AB%E5%9C%B0-%E5%83%A7-green.svg?style=plastic)](https://weibo.com/237800789)   

### <a name='preface'>前言（README.md）</a>

```html
本仓库是我整理的前端常见面试题，大部分由我整理，其中个别部分参考网上其他资料，感谢！ 
当然，本仓库的内容由于个人技术所限，和时间关系，有些知识点难免发生错误和遗漏，
还望大家批评指正。探索前端的路上我们应该永远保持谦卑和热情，循序渐进，打好基础，
不可只背“面试题”混进公司，根深才稳健。欢迎大家Star和提交issues。
本资料仅供大家学习参考使用！
```

NO.1 	[README](https://github.com/famensaodiseng/Front-End/edit/master/README.md)      
NO.2 	[前端面试宝典第一版](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%AC%E4%B8%80%E7%89%88.md)       
NO.3  	[前端笔记版本第二版](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88.md)     
NO.4       [前端笔记版本第三版](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%AC%E4%B8%89%E7%89%88.md)	    
NO.5	[前端笔记版本第四版](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E7%AC%AC%E5%9B%9B%E7%89%88.md)    
NO.6 	[vue常见问题](https://github.com/famensaodiseng/Front-End/blob/master/vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.md)   
NO.7 	[react常见问题](https://github.com/famensaodiseng/Front-End/blob/master/react%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.md)    
NO.8  	[angular常见问题](https://github.com/famensaodiseng/Front-End/blob/master/angular%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.md)   
NO.9 	[简历经验分享](https://github.com/famensaodiseng/Front-End/blob/master/%E7%AE%80%E5%8E%86%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.md)     
NO.10     [人事常见面试题](https://github.com/famensaodiseng/Front-End/blob/master/%E4%BA%BA%E4%BA%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.pdf) 

### 欢迎大家一起交流提高       

### AMD和CMD是什么？它们的区别有哪些？
+ AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。	
  CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

  这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。  
  区别：
  1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
  2. CMD 推崇依赖就近，AMD 推崇依赖前置。  
  3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

### web开发常见的漏洞

+	XSS（跨站脚本攻击）：其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。
  + SQL注入：用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。

### cookie和session
+ 你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，
  都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie
  里的内容来判断使用者，送出特定的网页内容给你。
   当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识
  （称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来
  使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相
  关联的session id	

### MVC BFC
+  mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。

  +BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。

### HTTP状态码：
1.消息  2.成功 3.重定向 4.请求错误 5.服务器错误

 304：响应禁止包含消息体，如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 
 305：被请求的资源必须通过指定的代理才能被访问。  
 400：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求，或者请求参数有误。   
 403：服务器已经理解请求，但是拒绝执行它。   
 404：请求失败，请求所希望得到的资源未被在服务器上发现。   
 500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。    

### Position的四个属性详解

+	Position的四个属性：static，fixed，absolute，relative
  首先，static，是position属性的默认值，也就是无特殊定位，遵循html定位规则。然后，fixed，是相对于浏览器窗口进行定位，不随页面的上下翻动而移动，比如固定在页面末端的二维码等。   
  下来，就是absolute，它是相对于它的第一个父元素进行定位，如果你想让这个div#demo里的一个子div#sub相对于#demo定位在右上角的某个地方，应该给#demo相对定位，#sub绝对定位。 此时，它的第一个父元素就是id=demo的div；否则它的父元素就是body，这样它的位置在页面中保持不变，但是随着页面移动会发生变化（区别fixed）。	
  最后，relative，relative是相对于自己来定位的，相对于其正常位置进行定位。例如：#demo{position:relative;top:-50px;},这时#demo会在相对于它原来的位置上移50px。 	
  P.S:采用左列left浮动，右列不浮动，采用margin-left定位的方式。  

### 理解CSS盒子模型
+ 什么是CSS的盒子模式呢？为什么叫它是盒子？先说说我们在网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。
  +CSS盒子模式			
  这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也具有这些属性，所以叫它盒子模式。那么内容就是盒子里装的东西；而填充就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框就是盒子本身了；至于边界则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出嘛。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子（DIV嵌套），与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。而且填充只有宽度属性

### 区别onmouseover和mouseover
+  onmouseover是Event 对象的一个属性，Mouseover是jQuery中的一个事件 。

  推荐使用jQuery，直接执行方法$("#id").mouseover(function(){});
  完全使用js则是如下写法：document.getElementById("id").onmouseover=function(){};
  document.getElementsByTagName("body")[0].style.backgroundColor="pink”; //注意不要忘了style，深刻理解DOM的本质。
### DNS的工作原理（递归和迭代）（应用层）

DNS的工作原理及过程分下面几个步骤：			
第一步：客户机提出域名解析请求，并将该请求发送给本地的域名服务器。  
第二步：当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该纪录项，则本地的域名服务器就直接把查询的结果返回。    
第三步：如果本地的缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器，然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域) 的主域名服务器的地址。  
第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。	 
第五步：重复第四步，直到找到正确的纪录。  
第六步：本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。

### 什么是DOM事件处理程序？

首先要理解什么是DOM？Dom是针对HTML文档的一个API。什么是事件流？事件流分为：事件冒泡（IE的事件流）和事件捕获。事件冒泡就是由最具体的元素开始接收，然后逐级向上；事件捕获就是由不太具体的元素开始接收，逐级向下，最具体的元素最后才接收到事件。  
DOM事件处理程序分为DOM0级、DOM2级。DOM0级具有简单，跨浏览器的优势，它是把函数赋值给一个事件的处理程序属性。    
例如：btn.onlick=function（）{。。。}；DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作。addEventListener()和removeEventListener()。它们都接收三个参数，要处理的事件名、作为事件处理程序的函数和布尔值。布尔值为true表示在捕获阶段调用事件处理程序，布尔值为false是在冒泡处调用。	
注意：事件名要去掉“on”。通过addEventListener（）添加的事件，只能由removeEventListener()删除。IE存在兼容问题，可以用attachEvent()添加事件和detachEvent（）删除事件。接收两个参数，事件处理程序的名称和函数。注意：事件名此时要加”on”。
### 如果给一个元素同时绑定两个事件，会怎么样？
Dom 0级和Dom 2级都可以给一个元素添加多个事件，Dom 0级的每个事件只支持一个事件处理程序，如果绑定同一个事件，那么后边的那个事件，函数会覆盖掉前边的那个事件函数。Dom2级可以添加多个事件处理程序，他们会按照添加的顺序触发。
### jQuery源码分析：
选择器 Sizzle引擎 回调对象 - Callbacks 事件绑定 - 绑定设计
DOM操作方法与核心 Ajax - 整体结构
 选择器 Sizzle引擎：个人认为，sizzle选择器是增强版的querySelectorAll 函数：返回指定元素节点的子树中匹配selector的节点集合，采用的是深度优先预查找；如果没有匹配的，这个方法返回空集合） 
### 几个前端框架的区别：
jQuery 		
核心js只有50K，小而精，占用带宽小，侧重于对js dom编程。有灵活便捷的Ajax请求和回调操作。		
ExtJS 		
一整套带有UI的js库，封装得很多，核心js就600多K，这么大的东西门户网站当然就别想了，里面的效果当然也不会运用到门户网站，所以它是专门为管理系统而生的。		
3、YUI 		
或者是类似于网盘应用这种东东。 		
4.Dojo 		
Dojo是功能最为强大的javascript框架，刻意提醒一下：功能最强大。所以它几乎包含了所有你可能想要用到的东西。）。 Dojo更适合企业应用和产品开发的需要，		
5、Prototype 		
最成熟的。但个人认为可以被Jquery取代。两者相似度也比较高。
###	前端性能优化
①对于页面来说：尽量减少DOM元素的数量
减少iframe的数量
减少http的请求次数
提前加载
②对于CSS来说：将样式表置顶
使用link代替@important
　　区别1：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
　　区别2：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。link支持定义RSS(简易信息聚合).
区别3：link支持使用Javascript控制DOM去改变样式；而@import不支持。

③对于JS来说： 将脚本置底
使用外部JS和CSS文件
精简JS和CSS文件，去除重复脚本

 目前，前端性能测试的执行工具也有很多，比如YSlow，Page Speed，dynaTrace AJAX Edition，webload等等。
### HTML语义化

就是当你写html时，要按照人们的思考逻辑写。不但要自己能看懂，也要让别人也能看懂，不要让别人觉得你的代码很乱。语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。
语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。
语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。

### 说说jsonp，getJSON(),getScript():

Jsonp（解决跨域）
一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
因为，<script> 元素的这个开放策略。		
getJSON():		
所以getJSON和ajax的方式(实际就是jsonp)想比较，也就是callback函数一个是自动生成的函数名，一个是手工指定的函数名。		
getScript():getScript() 方法使用 AJAX 的 HTTP GET 请求获取和执行 JavaScript。

### prototype属性
+	每一个构造函数都有一个属性叫做原型(prototype)。这个属性非常有用：为一个特定类声明通用的变量或者函数。prototype是一个对象，因此，你能够给它添加属性。你添加给prototype的属性将会成为使用这个构造函数创建的对象的通用属性。
###js实现类:
+	构造函数方式：
  由于js类的定义方法和函数的定义方法一样，所以定义构造函数的同时就定义了类。构造函数内的方法和属性也就是类中的方法和属性。
  原型方式 
  该方式利用了对象的prototype属性。首先定义了一个空函数，然后通过prototype属性来定义对象的属性。调用该函数时，原型的所有属性都会立即赋予要创建的对象			
### js继承
+	继承是指一个对象直接使用另一对象的属性和方法
  实现方法：
  对象冒充，及call（）Apply（）参见上述call和apply的用法。
  原型链方式：
  js中每个对象均有一个隐藏的proto属性，一个实例化对象的proto属性指向其类的prototype方法，而这个prototype方法又可以被赋值成另一个实例化对象，这个对象的proto又需要指向其类，由此形成一条链。

那么proto是什么？我们在这里简单地说下。每个对象都会在其内部初始化一个属性，就是proto，当我们访问一个对象的属性 时，如果这个对象内部不存在这个属性，那么他就会去proto里找这个属性，这个proto又会有自己的proto，于是就这样 一直找下去，也就是我们平时所说的原型链的概念。

### js事件委托
+	“事件处理程序过多”问题的解决方案就是事件委托。
  事件委托利用的是事件冒泡机制，只制定一事件处理程序，就可以管理某一类型的所有事件（使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序）。
  这里要用到事件源：event 对象，需要用到target属性，其 事件属性可返回事件的目标节点（触发该事件的节点）
### js自定义事件：
js自定义事件用处较多，最主要的就是实现观察者模式.
观察者模式( 又叫发布者-订阅者模式 )应该是最常用的设计模式之一。
平时接触的dom事件. 也是js和dom之间实现的一种观察者模式.
### 回调函数：
函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。函数b是你以参数形式传给函数a的，那么函数b就叫回调函数。回调函数可以继续扩展一个函数的功能，可以是程序非常灵活。
##JavaScript内置对象有以下几种。 		

tring对象：处理所有的字符串操作 			
ath对象：处理所有的数学运算 			
ate对象：处理日期和时间的存储、转化和表达 	
Array对象：提供一个数组的模型、存储大量有序的数据
vent对象：提供JavaScript事件的各种处理信息 	

##自适应问题		
```
自适应指的就是指其长（宽）度可以根据浏器窗口的大小自动改变其长（宽）度（随浏览器长（宽）的改变而改变）,而不会被浏览器遮住。	
```

现方法（以左侧固定，右侧自适应为例）：		
①采用左列 left 浮动，右列不浮动，采用 margin-left 定位的方式。   
②左列使用绝对定位，右列使用 margin-left 定位。  

### 从输入 URL 到页面加载完的过程中都发生了什么事情？

①首先如果我们如果输入的不是ip地址，而是域名的话，就需要IP解析，DNS域名解析（具体见DNS工作机制）。
②解析出来对应的IP后，如不包含端口号，http协议默认端口号是80；https（http+ssl（传输层））是430！然后向IP发起网络连接，根据http协议要求，组织一个请求的数据包，里面包含大量请求信息。
③服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。
④开始根据资源的类型，将资源组织成屏幕上显示的图像，这个过程叫渲染，网页渲染是浏览器最复杂、最核心的功能。
⑤将渲染好的页面图像显示出来，并开始响应用户的操作。
###Unicode和ASCII的区别是什么回答		
计算机发明后，为了在计算机中表示字符，人们制定了一种编码，叫ASCII码。
中国人利用连续2个扩展ASCII码的扩展区域（0xA0以后）来表示一个汉字，该方法的标准叫GB-2312。因为各个国家地区定义的字符集有交集，因此使用GB-2312的软件，就不能在BIG-5的环境下运行（显示乱码），反之亦然。
为了把全世界人民所有的所有的文字符号都统一进行编码，于是制定了UNICODE标准字符集。UNICODE 使用2个字节表示一个字符(unsigned shor int、WCHAR、_wchar_t、OLECHAR)。			
### Null和undefined的区别：
undefined表示变量声明但未初始化时的值，javascript解释器不知道这是什麽东西,会抛出"未定义"的错误
null表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null值表示一个空对象指针，意思是你定义了它,但它没有分配内存空间。

### Canvas 与 SVG 的比较：		
SVG 是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。
Svg支持事件处理器，canvas不支持事件处理器
在 SVG 中，每个被绘制的图形均被视为对象，而canvas能够以 .png 或 .jpg 格式保存结果图像
如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

### div+css的布局较table布局有什么优点？

改版的时候更方便 只要改css文件。
页面加载速度更快、结构化清晰、页面显示简洁。
表现与结构相分离。
易于优化（seo）搜索引擎更友好，排名更容易靠前。

### 请描述一下cookies，sessionStorage和localStorage的区别？

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

### 请尽可能详尽的解释ajax的工作原理

Ajax的工作原理相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化。这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，从而达到节约ISP的空间及带宽租用成本的目的。

 简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。

### 什么是三元表达式？“三元”表示什么意思？

三元运算符:
三元如名字表示的三元运算符需要三个操作数。
语法是 条件 ? 结果1 : 结果2;. 这里你把条件写在问号(?)的前面后面跟着用冒号(:)分隔的结果1和结果2。满足条件时结果1否则结果2。			

浏览器标准模式和怪异模式之间的区别是什么？
所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式

### html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？

新特性：	

1. 拖拽释放(Drag and drop) API 				
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search  
9. 新的技术webworker, websocket, Geolocation
   移除的元素：
10. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
11. 对可用性产生负面影响的元素：frame，frameset，noframes；

**支持HTML5新标签：**

IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：



### 你如何对网站的文件和资源进行优化？

文件合并
文件最小化/文件压缩
使用CDN托管
缓存的使用
什么是响应式设计？
它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常	

### 你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 

- 首先划分成头部、body、脚部；。。。。。 
- 实现效果图是最基本的工作，精确到2px；
  与设计师，产品经理的沟通和项目的参与
  做好的页面结构，页面重构和用户体验
  处理hack，兼容、写出优美的代码格式
  针对服务器的优化、拥抱 HTML5。

### 你能描述一下渐进增强和优雅降级之间的不同吗?

**渐进增强** 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。		
**优雅降级** graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

　　区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。      
　**“优雅降级”观点**
　　“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。     
　**“渐进增强”观点**
　　“渐进增强”观点则认为应关注于内容本身。
　　内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。

### 为什么利用多个域名来存储网站资源会更有效？

- CDN缓存更方便 
- 突破浏览器并发限制 
- 节约cookie带宽 
- 节约主域名的连接数，优化页面响应速度 
- 防止不必要的安全问题

### 请描述一下cookies，sessionStorage和localStorage的区别？　

　sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

### Ajax 是什么? 如何创建一个Ajax？

Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果
基本步骤：

### 如何解决跨域问题?

理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域        
出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案

### 页面编码和被请求的资源编码如果不一致如何处理？

对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码

### 简述ajax 的过程。

1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新

### 阐述一下异步加载。

1. 异步加载的方案： 动态插入 script 标签    
2. 通过 ajax 去获取 js 代码，然后通过 eval 执行     
3. script 标签上添加 defer 或者 async 属性       
4. 创建并插入 iframe，让它异步执行 js         

### 请解释一下 JavaScript 的同源策略。

同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。

### GET和POST的区别，何时使用POST？

GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制
在以下情况中，请使用 POST 请求：

1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### ajax 的交互模型?同步和异步的区别?如何解决跨域问题?

1. 通过异步模式，提升了用户体验
2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

### Ajax的最大的特点是什么。

Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；      
**ajax的缺点**
 1、ajax不支持浏览器back按钮。
 2、安全问题 AJAX暴露了与服务器交互的细节。
 3、对搜索引擎的支持比较弱。
 4、破坏了程序的异常机制。

### ajax请求的时候get 和post方式的区别

get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。
post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。

### 解释jsonp的原理，以及为什么不是真正的ajax

　　Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术

### 什么是Ajax和JSON，它们的优缺点。

Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。
优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验
缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；
JSON是一种轻量级的数据交换格式，ECMA的一个子集
优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）

### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

**分为4个步骤：**

1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。
2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
4. 此时，Web 服务器提供资源服务，客户端开始下载资源。      

### ajax请求的时候get 和post方式的区别

get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。          
post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。      

### ajax请求时，如何解释json数据      

使用eval() 或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。   

### 为什么利用多个域名来存储网站资源会更有效？

确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。

### 请说出三种减低页面加载时间的方法

1、压缩css、js文件 2、合并js、css文件，减少http请求 3、外部js、css文件放在最底下 4、减少dom操作，尽可能用变量替代不必要的dom操作

### Javascript作用链域?

理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。

### 谈谈This对象的理解。

理解不同形式的函数调用方式下的this指向，理解事件函数、定时函数中的this指向，函数的调用形式决定了this的指向。

### eval是做什么的？

它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2个步骤，一次解析成js语句，一次执行）

### 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？

[1].在IE中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,不管是用户触发的，还是其他事件,都会更新window.event对象.所以在代码中，只要调用window.event就可以获取事件对象， 再event.srcElement就可以取得触发事件的元素进行进一步处理. 
[2].在FireFox中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，FireFox把事件对象自动传给事件处理程序.
关于事件的兼容性处理要熟练掌握，事件对象具体哪些属性存在兼容性问题，IE与标准事件模型事件冒泡与事件捕获的支持要理解

### new操作符具体干了什么呢?

1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

### 模块化开发怎么做？

理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用

### AMD、CMD规范区别？      

理解这两种规范的差异，主要通过requirejs与seajs的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则

### requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）

核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存

### 让你自己设计实现一个requireJS，你会怎么做？

核心是实现js的加载模块，维护js的依赖关系，控制好文件加载的先后顺序

### 异步加载的方式有哪些？

- 方案一：<script>标签的async="async"属性（详细参见：script标签的async属性）
- 方案二：<script>标签的defer="defer"属性
- 方案三：动态创建<script>标签
- 方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）
- 方案五：iframe方式

### documen.write和 innerHTML的区别?

document.write是重写整个document, 写入内容是字符串的html
innerHTML是HTMLElement的属性，是一个元素的内部html内容

### DOM操作——怎样添加、移除、移动、复制、创建和查找节点?

（1）创建新节点
​      createDocumentFragment()    //创建一个DOM片段
​      createElement_x()   //创建一个具体的元素
​      createTextNode()   //创建一个文本节点
（2）添加、移除、替换、插入
​      appendChild()
​      removeChild()
​      replaceChild()
​      insertBefore()
（3）查找
​      getElementsByTagName()    //通过标签名称
​      getElementsByName()    //通过元素的Name属性的值
​      getElementById()    //通过元素Id，唯一性

### call() 和 .apply() 的含义和区别？

apply的参数是数组形式，call的参数是单个的值，除此之外在使用上没有差别，重点理解这两个函数调用的this改变

### 数组和对象有哪些原生方法，列举一下？

Array.concat( ) 连接数组 
Array.join( ) 将数组元素连接起来以构建一个字符串 
Array.length 数组的大小 
Array.pop( ) 删除并返回数组的最后一个元素 
Array.push( ) 给数组添加元素 
Array.reverse( ) 颠倒数组中元素的顺序 
Array.shift( ) 将元素移出数组 
Array.slice( ) 返回数组的一部分 
Array.sort( ) 对数组元素进行排序 
Array.splice( ) 插入、删除或替换数组的元素 
Array.toLocaleString( ) 把数组转换成局部字符串 
Array.toString( ) 将数组转换成一个字符串 
Array.unshift( ) 在数组头部插入一个元素
Object.hasOwnProperty( ) 检查属性是否被继承 
Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型 
Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性 
Object.toLocaleString( ) 返回对象的本地字符串表示 
Object.toString( ) 定义一个对象的字符串表示 
Object.valueOf( ) 指定对象的原始值

### JS 怎么实现一个类。怎么实例化这个类

严格来讲js中并没有类的概念，不过js中的函数可以作为构造函数来使用，通过new来实例化，其实函数本身也是一个对象。

### JavaScript中的作用域与变量声明提升？

理解JavaScript的预解析机制，js的运行主要分两个阶段：js的预解析和运行，预解析阶段所有的变量声明和函数定义都会提前，但是变量的赋值不会提前

### 如何编写高性能的Javascript？

使用 DocumentFragment 优化多次 append
通过模板元素 clone ，替代 createElement
使用一次 innerHTML 赋值代替构建 dom 元素
使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素 
使用 Array 做为 StringBuffer ，代替字符串拼接的操作 
将循环控制量保存到局部变量
顺序无关的遍历时，用 while 替代 for
将条件分支，按可能性顺序从高到低排列
在同一条件子的多（ >2 ）条件分支时，使用 switch 优于 if
使用三目运算符替代条件分支 
需要不断执行的时候，优先考虑使用 setInterval

### 那些操作会造成内存泄漏？

闭包，循环

### javascript对象的几种创建方式？

1. 工厂模式
2. 构造函数模式
3. 原型模式
4. 混合构造函数和原型模式
5. 动态原型模式
6. 寄生构造函数模式
7. 稳妥构造函数模式

### javascript继承的 6 种方法？

1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

### eval是做什么的？

1. 它的功能是把对应的字符串解析成JS代码并运行
2. 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）

### JavaScript 原型，原型链 ? 有什么特点？

1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

### 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？

1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为
2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件
3. ev.stopPropagation();

### JavaScript原型，原型链 ? 有什么特点？

- 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
- 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。

### 平时如何管理你的项目，如何设计突发大规模并发架构？

先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等
编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；
标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；
页面进行标注（例如 页面 模块 开始和结束）；
CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）
JS 分文件夹存放 命民以该JS 功能为准英文翻译；
图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

### 那些操作会造成内存泄漏？

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧？
Node.js、Mongodb、npm、MVVM、MEAN、react、angularjs

### 如何解析json？

用ajax去请求json数据，在回调函数里，把数据传过到函数里。通过用一个for循环，用innerHTML和jQuery的方法html（）的方法，渲染到页面里。

### 简述下cookie的操作，还有cookie的属性都知道哪些？

Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。
Cookie是客户端的存储空间，由浏览器来维持。
如果不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。

### SQL是什么？

SQL 是用于访问和处理数据库的标准的计算机语言。
•	SQL 指结构化查询语言
•	SQL 使我们有能力访问数据库
•	SQL 是一种 ANSI 的标准计算机语言
SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。

### 什么是 MySQL？

•	MySQL 是一种数据库服务器
•	MySQL 支持标准的 SQL
•	MySQL 可在许多平台上编译
•	MySQL 可免费下载使用

### 客户端数据存储，请描述一下cookies，sessionStorage和localStorage的区别？

cookies兼容所有的浏览器，Html5提供的storage存储方式。
cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。			
存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。				
数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。			
作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

### 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?

**路由 Router**					 		
前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。
Web 服务并不会解析 hash，也就是说 # 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 window.location.hash 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。

优点可以控制  业务逻辑  做无页面刷新  体验更

缺点  页面不刷的话无法释放内存，如果过多的操作会造成页面体验不好。

### 模块化开发怎么做？

理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用

### AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？

1、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.	
2、CMD 推崇依赖就近，AMD 推崇依赖前置。		

1. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

### requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）

核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存

### 异步编程的四个方法

（1）回调函数（基本方法）
优点：简单容易理解和部署
缺点:不利于代码的阅读和维护，程序比较混乱
（2）事件监听（采用事件驱动模式）
绑“done”的事件
（1）	发布/订阅（观察者模式）一对多
让多个观察者对象 同时监听某一个主题对象，这个主题对象发生变化就会通知所有观察者，使他们自动更新自己
（2）	Promise对象
是common.js工作提出的一种规范，每个异步任务返回一个promise对象，该对象有then的方法允许回调

### JSONP原理

只要你聊到跨域，就必须聊到JSONP，那么就必须要讲一下JSONP的实现原理，以及你在项目中那个需求使用了JSONP，这里简单讲就是HTML里面所有带src属性的标签都可以跨域，如iframe，
img，script等。所以可以把需要跨域的请求改成用script脚本加载即可，服务器返回执行字符串，但是这个字符串是在window全局作用域下执行的，你需要把他返回到你的代码的作用域内，
这里就需要临时创建一个全局的回调函数，并把到传到后台，最后再整合实际要请求的数组，返回给前端，让浏览器直接调用，用回调的形式回到你的原代码流程中。

### 页面重构师

  做为一个专职的页面重构者，我们从事的工作简单的说就是“将设计稿转换成WEB页面”，这一过程可以很简单到直接把PSD从PS里导出成网页；也可复杂到需要考虑页面中每个标签的使用，考虑“页面性能”。以“前端工程师”为目标的同学可能会不愿承认将页面重构这块分出来，但随着工种的细分，加上页面重构本身的专业性，独立为一个职业也不是不可能，至少我现在从事的就是一个专职的职位。如果你觉得一个前端工程师必须去画设计稿，可以不理会下面的内容。			
​			
单纯的页面重构，所涉及到的工作内容一般是“分析设计稿=>切图=>写HTML和CSS”，虽然看起来很少，但要做好这份工作，绝非所想的那么容易。原因很简单：工作内容单一，在时间和工作量上必会很苛刻，往往跟设计师的工作时间是3:1，即设计师给三天的时间，制作只给一天的时间完成；在这种工作强度下，很多人都是靠着对这份工作的喜爱在维持着，一旦工作热情消失，很容易就会变得枯燥，保持热情也成了重构工作者（也许是所有参加工作的人）应该具备的能力。
 跟“前端工程师”所要求的有所不同，“页面重构”虽然也是“前端工程师”的一个范畴，在职业化中，对专职的页面重构者，要求当然也更高。不单是做出页面，而是做出好页面。又引出另一个话题，“何为好页面？”，

**一般包括下面几点**：											

  1. 结构完整，可通过标准验证
  2. 标签语义化，结构合理 
  3. 充分考虑到页面在站点中的“作用和重要性”，并对其进行有针对性的优化		

### 为何选择前端这个方向和对前端的理解

第一的话就是对前端很感兴趣，之前也接触过其他的语言，但是直到接触到前端才发现真的有兴趣做下去，兴趣是一个人最好的老师，

第二的话前端很有前途，像现在nodejs，rn，微信小程序这类工具和框架可以让前端进行后端和移动开发，所以我觉得前端的前途会更多一点。

理解：

首先前端工程师最核心的技能还是：Html、CSS、JS。前端负责的是用户可以看到的部分，所以也是最接近用户的工程师。同时在产品研发流程中前端要同时与产品、设计、后端等很多人合作。

### Vue双向数据绑定的实现

vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者（文本节点则是作为订阅者），在收到消息后执行相应的更新操作。

compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

AngularJS 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变。

### react和vue有哪些不同 说说你对这两个框架的看法

都用了virtual dom的方式, 性能都很好

ui上都是组件化的写法，开发效率很高

vue是双向数据绑定，react是单项数据绑定，当工程规模比较大时双向数据绑定会很难维护

vue适合不会持续的  小型的web应用，使用vue.js能带来短期内较高的开发效率. 否则采用react

### let和const的区别

let声明的变量可以改变，值和类型都可以改变，没有限制。

const声明的变量不得改变值

### 平时用了es6的哪些特性，体验如何 和es5有什么不同

let const关键字 箭头函数 字符串模板 class类 模块化 promise

es5 require react.createclass

### 浏览器原生支持module吗，如果支持，会带来哪些便利

不支持

### 介绍一下你对webpack的理解，和gulp有什么不同

Webpack是模块打包工具，他会分析模块间的依赖关系，然后使用loaders处理它们，最后生成一个优化并且合并后的静态资源。

gulp是前端自动化工具 能够优化前端工作流程，比如文件合并压缩

### webpack打包速度慢，你觉得可能的原因是什么，该如何解决

模块太多

Webpack 可以配置 externals 来将依赖的库指向全局变量，从而不再打包这个库 或者dllplugin

webpack-parallel-uglify-plugin 并行压缩

CommonsChunkPlugin提取公共的模块

happypack 多进程构建

### http响应中content-type包含哪些内容

请求中的消息主体是用何种方式编码

application/x-www-form-urlencoded

这是最常见的 POST 提交数据的方式 按照 key1=val1&key2=val2 的方式进行编码

application/json

告诉服务端消息主体是序列化后的 JSON 字符串

### 浏览器缓存有哪些，通常缓存有哪几种方式

强缓存 强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。

协商缓存 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。

### HTTP头信息控制缓存

Expires（强缓存）+过期时间   Expires是HTTP1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间

Cache-control（强缓存） 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断 管理更有效，安全一些 Cache-Control: max-age=3600

服务端返回头Last-Modified/ 客户端请求头If-Modified-Since（协商缓存） 标示这个响应资源的最后修改时间。Last-Modified是服务器相应给客户端的，If-Modified-Sinces是客户端发给服务器，服务器判断这个缓存时间是否是最新的，是的话拿缓存。

服务端返回头Etag/客户端请求头If-None-Match（协商缓存） etag和last-modified类似，他是发送一个字符串来标识版本。

强缓存不请求服务器，客户端判断 、协商缓存要请求服务器

### 平时是怎么学新技术的

伯乐在线 infoq 掘金 简书 慕课网

13：Node，Koa用的怎么样

koa是一个相对于express来说,更小,更健壮,更富表现力的Web框架，不用写回调

koa是从第一个中间件开始执行，遇到next进入下一个中间件，一直执行到最后一个中间件，在逆序

async await语法的支持

 

### 使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的

commonjs 同步 顺序执行

AMD 提前加载，不管是否调用模块，先解析所有模块 requirejs 速度快 有可能浪费资源

CMD 提前加载，在真正需要使用(依赖)模块时才解析该模块 seajs 按需解析 性能比AMD差

 

### 介绍一下闭包和闭包常用场景

闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数.
本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
应用场景 设置私有变量和方法让这些变量的值始终保持在内存中还有读取函数内部变量。

不适合场景：返回闭包的函数是个非常大的函数

闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

### 为什么会出现闭包这种东西，解决了什么问题

受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念

### 介绍一下你所了解的作用域链,作用域链的尽头是什么，为什么

每一个函数都有一个作用域，比如我们创建了一个函数，函数里面又包含了一个函数，那么现在 就有三个作用域，这样就形成了一个作用域链。

作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域链往上找。

### 一个Ajax建立的过程是怎样的，主要用到哪些状态码

ajax：在不切换页面的情况下完成异步的HTTP请求

(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.

### 简单介绍一下promise，他解决了什么问题

Promise，就是一个对象，用来传递异步操作的消息。有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。

有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。

### 判断数组有哪些方法

a instanceof Array
a.constructor == Array
Object.prototype.toString.call(a) == [Object Array]

### 跨域通信有哪些方案，各有什么不同

JSONP：由于同源策略的限制，XmlHttpRequest只允许请求当前源，script标签没有同源限制

通过动态<script>元素使用，使用时为src指定一个跨域url。回调函数处理JSON数据  兼容性好 不支持post

简述原理与过程：首先在客户端注册一个callback, 然后把callback的名字传给服务器。此时，服务器先生成一个function , function 名字就是传递上来的参数。最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里

### 多页面通信有哪些方案，各有什么不同

localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。

settimeout+cookie

### 用Node实现一个用户上传文件的后台服务应该怎么做

multer模块

### XSS和CSRF攻击

xss：比如在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS

写一个脚本将cookie发送到外部服务器这就是xss攻击但是没有发生csrf

防范：对输入内容做格式检查 输出的内容进行过滤或者转译

CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求 如恶意发帖，删帖

比如在论坛发了一个删帖的api链接 用户点击链接后把自己文章给删了 这里就是csrf攻击没有发生xss

防范：验证码 token 来源检测

### 圣杯布局和双飞翼布局

### 【圣杯布局】

html代码中  middle部分首先要放在container的最前部分。然后是left,right

1.将三者都 float:left , 再加上一个position:relative (因为相对定位后面会用到）

2.middle部分 width:100%占满

3.此时middle占满了，所以要把left拉到最左边，使用margin-left:-100%

4.这时left拉回来了，但会覆盖middle内容的左端，要把middle内容拉出来，所以在外围container加上 padding:0 220px 0 200px

5.middle内容拉回来了，但left也跟着过来了，所以要还原，就对left使用相对定位 left:-200px  同理，right也要相对定位还原 right:-220px

6.到这里大概就自适应好了。如果想container高度保持一致可以给left middle right都加上min-height:130px

### 【双飞翼布局】

前几步都一样 后边把外围padding和相对定位做法换成内层margin

给middle增加一个内层div-- middle-inner, 然后margin:0 220px 0 200px

47:offsetHeight, scrollHeight, clientHeight分别代表什么

clientHeight：包括内容可见部分的高度，可见的padding；不包括border，水平方向的scrollbar，margin。

offsetHeight：包括内容可见部分的高度，border，可见的padding，水平方向的scrollbar（如果存在）；不包括margin。

scrollHeight：包括内容的高度（可见与不可见），padding（可见与不可见）；不包括border，margin。

### 垂直居中

单行行内元素 1.可以设置padding-top,padding-bottom 2.将height和line-height设为相等

多行行内元素 1.可以将元素转为table样式，再设置vertical-align：middle; 2.使用flex布局

块级元素

已知高度绝对定位负边距

未知高度transform: translateY(-50%);

flex布局 
display: flex;
justify-content: center;
align-items: center;
49：transition的属性值和应用

属性的名称 过渡时间 时间曲线 延迟

### rem和em的区别

em相对于父元素，rem相对于根元素

### 严格模式的特性

严格模式对Javascript的语法和行为，都做了一些改变。

全局变量必须显式声明。

对象不能有重名的属性

函数必须声明在顶层

消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
消除代码运行的一些不安全之处，保证代码运行的安全；
提高编译器效率，增加运行速度；
为未来新版本的Javascript做好铺垫。

### js的原型链，如何实现继承？

原型链实际上就是js中数据继承的继承链。
在访问一个实例的属性的时候，现在实例本身中找，如果没找到就去它的原型中找，还没找到就再往上找，直到找到。这就是原型链。

### 输入网址后到页面展现的过程

通过dns解析获取ip

tcp链接

客户端发送http请求

tcp传输报文

服务器处理请求返回http报文

客户端解析渲染页面 （构建DOM树 –> 构建渲染树 –> 布局渲染树：计算盒模型位置和大小 –> 绘制渲染树）

 

### UMD规范和ES6模块化，Commonjs的对比

CommonJS是一个更偏向于服务器端的规范。用于NodeJS 是同步的

AMD是依赖前置的

CMD推崇依赖就近，延迟执行。可以把你的依赖写进代码的任意一行

AMD和CMD都是用difine和require，但是CMD标准倾向于在使用过程中提出依赖，就是不管代码写到哪突然发现需要依赖另一个模块，那就在当前代码用require引入就可以了，规范会帮你搞定预加载，你随便写就可以了。但是AMD标准让你必须提前在头部依赖参数部分写好（没有写好？ 倒回去写好咯）。这就是最明显的区别。

UMD写一个文件需要兼容不同的加载规范

ES6通过import、export实现模块的输入输出。其中import命令用于输入其他模块提供的功能，export命令用于规定模块的对外接口。

### nginx的好处？和node的比较

高并发 响应快

区别不是很大，一个更专业，一个更全面:
1.相似点:
1.1异步非阻塞I/O, 事件驱动;
2.不同点:
2.1Nginx 采用C编写，更性能更高，但是它仅适合于做web服务器，用于反向代理或者负载均衡等服务；Nginx背后的业务层编程思路很还是同步编程方式，例如PHP.
2.2NodeJs高性能平台，web服务只是其中一块，NodeJs在处理业务层用的是JS编写,采用的是异步编程方式和思维方式。
.框架问题

### 什么是 MVVM , 和 MVC 是什么区别, 原理是什么?

　　mvc的界面和逻辑关联紧密，数据直接从数据库读取，必须通过Controller来承上启下，通信都是单向的。mvvm的View 和 ViewModel可以互相通信，界面数据从viewmodel中获取。

父子组件怎么通信的?
　　vue：父组件是通过props属性给子组件通信  在子组件里面emit,在父组件监听
　　react：props传递  父给子传一个回调函数 将数据传给父亲处理

### css3动画和jquery动画的差别

1.css3中的过渡和animation动画都是基于css实现机制的，属于css范畴之内，并没有涉及到任何语言操作。效率略高与jQuery中的animate()函数，但兼容性很差。

2.jQuery中的animate()函数可以简单的理解为css样式的“逐帧动画”，是css样式不同状态的快速切换的结果。效率略低于css3动画执行效率，但是兼容性好。‍

### 如何解决ajax无法后退的问题

HTML5里引入了新的API，即：history.pushState, history.replaceState

可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。

onpopstate监听后退

### 分域名请求图片的原因和好处

浏览器的并发请求数目限制是针对同一域名的，超过限制数目的请求会被阻塞

浏览器并发请求有个数限制，分域名可以同时并发请求大量图片

### JavaScript为什么是单线程？eventloop

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

异步执行：

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

node里的process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高。

### http http2 https

http(超文本传输协议)是一种常用于应用层的协议，它是基于文本传输内容。

https可以称为http安全版，主要是http下增加了SSL(安全套接层)或者TSL(传输层安全)，在SSL或TSL在传输层对数据进行了加密处理。

http/2（超文本传输协议第二版），他对http进行了一些升级改造

新的二进制格式
多路复用
header压缩
支持server push

### react 相关

react router：

实现URL与UI界面的同步。其中在react-router中，URL对应Location对象，而UI是由react components来决定的，这样就转变成location与components之间的同步问题。

react事件：

React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。

### js css加载顺序

js全阻塞，css半阻塞

JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。
CSS 不会阻塞后续 DOM 结构的解析，不会阻塞其它资源(如图片)的加载，但是会阻塞 JS 文件的加载。
现代浏览器很聪明，会进行 prefetch 优化，浏览器在获得 html 文档之后会对页面上引用的资源进行提前下载。

### js为什么阻塞？

JS 运行在浏览器中，是单线程的，每个 window 一个 JS 线程，所以当然会阻塞后续 DOM 树的解析咯。
JS 有可能会修改 DOM 结构，给 DOM 添加样式等等，所以这就意味着在当前 JS 加载执行完成前，后续资源的加载可能是没有意义的

### css为什么阻塞js？

JS 代码在执行前，浏览器必须保证在 JS 之前的所有 CSS 样式都解析完成，不然不就乱套了，前面的 CSS 样式可能会覆盖 JS 文件中定义的元素样式，这是 CSS 阻塞后续 JS 执行的根本原因。

### defer，async？

JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载，这是在没有考虑到 defer, async 的情况下。

由于现代浏览器都存在 prefetch，所以 defer, async 可能并没有太多的用途，可以作为了解扩展知识，仅仅将脚本文件放到 body 底部就可以起到很不错的优化效果。
defer 和 async 都是异步加载脚本文件，defer异步加载，最后执行。
慎用 async，因为它完全不考虑依赖关系，只要下载完后就加载，不考虑此时页面样式先后的加载顺序，不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。
耗时较长的脚本代码可以使用 defer 来推迟执行。

### 三次握手四次挥手

第一次握手：客户端请求与服务端建立连接。第二次：服务端返回确认信息。第三次：客户端收到。

客户：喂？你在吗？我想跟你聊会儿天儿！（发送SYN请求同步报文）

服务：好的，我听着呢（发送SYN请求同步报文，意思是说，咱俩同步着呢），你说吧！（发送ACK确认报文，即可以说了）

客户：好的！（发送ACK确认报文，开始吐槽XXXX）

 

第一次挥手：客户端传完了，想要断开连接。第二次：服务端收到，半关闭状态。第三次：服务端没信息发了，发送结束报文。第四次：客户端确认，关闭。

然后客户有事儿要挂电话了，又有了下面一段对话，即四次挥手：

客户：我有事儿要挂电话了！（发送Fin结束报文，1次挥手）

服务：好吧（发送ACK确认报文，2次挥手），对了，还有个事儿要跟你说！

......

服务：好了，就这些了，挂了吧！（发送Fin结束报文，3次挥手）

客户：行，挂了吧！（发送ACK确认报文，4次挥手）

服务挂断电话.....

2MSL后......

客户：喂，你还在吗？

啪！（这才断开连接）



### 1. 阐述软件生命周期都有哪些阶段?常见的软件生命周期模型有哪些?

软件生命周期是指一个计算机软件从功能确定、设计，到开发成功投入使用，并在使用中不断地修改、增补和 完善，直到停止该软件的使用的全过程(从酝酿到废弃的过程)
生命周期从收到应用软件开始算起，到该软件不再使用为止。它有如下各方面的内容: 初始构思、需求分析、
功能设计、内部设计、文档计划、测试计划、文档准备、集成、测 试、维护、升级、再测试、逐步淘汰 (phase-out)、 等等
​    瀑布模型，迭代式模型，快速原型模型，螺旋模型

### 什么是版本控制，常用的版本控制系统有哪些?

版本控制(Revision control)是一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都 得到更新。
Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 https://git-scm.com/doc
SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统，相较于 RCS、CVS，它采用了分支管理系统， 它的设计目标就是取代 CVS。互联网上很多版本控制服务已从 CVS 迁移到 Subversion。

### 测试计划编写的六要素? 

why——为什么要进行这些测试		
what—测试哪些方面，不同阶段的工作内容 		
when—测试不同阶段的起止时间 			
where—相应文档，缺陷的存放位置，测试环境等 	
who—项目有关人员组成，安排哪些测试人员进行测试    
how—如何去做，使用哪些测试工具以及测试方法进行测试。



### 如果一个缺陷被提交后，开发人员认为不是问题，怎么处理?		

a)首先，将问题提交到缺陷管理库里面进行备案。 	
b)然后，要获取判断的依据和标准:   
 v.根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致的地方，提供缺陷是否确认的直接依据;    
 vi.如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地方，来确认是否是缺陷;    
 vii.根据用户的一般使用习惯，来确认是否是缺陷;   
 viii.与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷;    
c)合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不参杂个人情绪。 	  
d)等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的渠道，向上级反映，并有上级做出决定。



### 简述常用的 Bug 管理或者用例管理工具,并且描述其中一个工作流程？

常用:testlink，QC，mantis，禅道，TAPD，JIRA 。
TAPD:产品创建(需求，计划，模块)-->项目创建(PM 排期、任务分解)-->研发(编码、单元 测试等)-->测试 (测试计划，用例，执行，bug，报告等)。

### 什么是内存泄漏?什么是内存溢出?二者有什么区别?

内存溢出(OutOfMemory-OOM):指你的应用的内存已经不能满足正常使用了，堆栈已经达到系统设置 的最大值，进而导致崩溃，这是一种结果描述。
内存泄漏(Memory Leak):指你的应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资 源，这是一种状态描述。

### 10M兆宽带是什么意思?理论下载速度是多少?

首先我们要搞懂其中的区别，运营商说的 10M，完整的单位应该是 10Mbps(bps:比特率)，而我们讲 的下载速度单位是 MB，虽然都念兆，但是不一样的。
它们之间的换算关系是:1MB=8×1Mbps，换个方式看:1Mbps÷8=128KB，也就是说，运营商称的 10M 宽带，实际速度是 10Mbps÷8=1280KB，约 1.25MB。

### TCP和UDP有什么不同?

#### TCP:

优点:可靠 稳定   
TCP 的可靠体现在 TCP 在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认. 窗口. 重传. 拥塞控制机制，在数据传完之后，还会断开来连接用来节约系统资源。 缺点:慢，效率低，占用系统资源高，易被攻击    
在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制. 重传机制. 拥塞机制
等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个连接都会占用系统的 CPU，内存等硬件资源。因为 TCP 有确认机制. 三次握手机制，这些也导致 TCP 容易被利用，实 现 DOS. DDOS. CC 等攻击。

#### UDP:

优点:快，比 TCP 稍安全
UDP 没有 TCP 拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快，没有 TCP 的这
些机制，被攻击利用的机会就少一些，但是也无法避免被攻击。   
缺点:不可靠，不稳定     
因为没有 TCP 的这些机制，UDP 在传输数据时，如果网络质量不好，就会很容易丢包，造成数据
的缺失。      
适用场景:     
TCP:当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议;POP，SMTP等邮 件传输的协议      
UDP:对网络通讯质量要求不高时，要求网络通讯速度要快的场景 		

#### HTTP和HTTPS的区别?

安全性上的区别:HTTPS:HTTP 协议的安全加强版，通过在 HTTP 上建立加密层，对传输数据进行加密。 主要作用可以分为两种:一种是建立一个信息安全通道，来保证数据传输的安全;另一种就是确认网站的真 实性。		

表现形式:HTTPS 站点会在地址栏上显示一把绿色小锁，表明这是加密过的安全网站，如果采用了全球 认证的顶级 EV SSL 证书的话，其地址栏会以绿色高亮显示，方便用户辨认。			
​		
SEO:在 2015 年之前百度是无法收录 HTTPS 页面的，不过自从 2015 年 5 月份百度搜索全站 HTTPS 加密后，就已经可以收录 HTTPS 了。谷歌则是从 2014 年起便开始收录 HTTPS 页面，并且 HTTPS 页面权 重比 HTTP 页面更高。从 SEO 的角度来说，HTTPS 和 HTTP 区别不大，甚至 HTTPS 效果更好。		

技术层面:如果要说 HTTPS 和 HTTP 的区别，最关键的还是在技术层面。比如 HTTP 标准端口是 80，而 HTTPS 标准端口是 443;HTTP 无需证书，HTTPS 需要 CA 机构颁发的 SSL 证书;HTTP 工作于应用层， HTTPS 工作于传输层。

#### 说出HTTP状态保持的原理

a)	在用户登录之后，浏览器返回响应的时候会在响应中添加上cookie
b)	浏览器接收到cookie之后会自动保存
c)	当用户再次请求其他网页的时候，浏览器会自动带上之前保存的cookie
d)	服务接收到请求之后可以请 request 对象中取到cookie 判断当前用户是否登录

#### 说出CSRF 攻击的原理和防范措施

- a)	攻击原理：
  i.	用户C访问正常网站A时进行登录，浏览器保存A的cookie
  ii.	用户C再访问攻击网站B，网站B上有某个隐藏的链接或者图片标签会自动请求网站A的URL地址,例如表单提交，传指定的参数
  iii.	而攻击网站B在访问网站A的时候，浏览器会自动带上网站A的cookie
  iv.	所以网站A在接收到请求之后可判断当前用户是登录状态，所以根据用户的权限做具体的操作逻辑，造成网站攻击成功.
- b)	防范措施：
  i.	在指定表单或者请求头的里面添加一个随机值做为参数
  ii.	在响应的cookie里面也设置该随机值
  iii.	那么用户C在正常提交表单的时候会默认带上表单中的随机值，浏览器会自动带上cookie里面的随机值，那么服务器下次接受到请求之后就可以取出两个值进行校验
  iv.	而对于网站B来说网站B在提交表单的时候不知道该随机值是什么，所以就形成不了攻击

#### 前端安全什么是sql注入，什么是跨站脚本，什么是跨站请求伪造?

SQL 注入攻击是注入攻击最常见的形式(此外还有 OS 注入攻击(Struts 2 的高危漏洞就是通过 OGNL 实施	
OS 注入攻击导致的))，当服务器使用请求参数构造 SQL 语句时，恶意的 SQL 被嵌入到 SQL 中交给数据库执行。		
SQL 注入攻击需要攻击者对数据库结构有所了解才能进行，攻击者想要获得表结构有多种方式:	
(1)如果使用开源系统搭建网站，数据库结构也是公开的(目前有很多现成的系统可以直接搭建论坛，电商网站，虽然方便快捷但是风险是必须要认真评估的);
(2)错误回显(如果将服务器的错误信息直接显示在页面上，攻击者可以通过非法参数引发页面错误从而通过错误信息了解数据库结构，Web 应用应当设置友好的错误页，一方面符合最小惊讶原则，一方面屏蔽掉可能给系统 带来危险的错误回显信息);		
(3)盲注。防范 SQL 注入攻击也可以采用消毒的方式，通过正则表达式对请求参数进行验证，此外，参数绑定也是很好的手段，这样恶意的 SQL 会被当做 SQL 的参数而不是命令被执行，JDBC 中的 PreparedStatement 就是支持参数绑定的语句对象，从性能和安全性上都明显优于Statement。
XSS(Cross Site Script，跨站脚本攻击)是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意 脚本的攻击方式。跨站脚本攻击分有两种形式:	
反射型攻击(诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发 布含有恶意脚本的 URL 就属于这种方式)		
持久型攻击(将恶意脚本提交到被攻击网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面 执行，QQ 邮箱的早期版本就曾经被利用作为持久型跨站脚本攻击的平台)。	
CSRF 攻击(Cross Site Request Forgery，跨站请求伪造)是攻击者通过跨站请求，以合法的用户身份进行非 法操作(如转账或发帖等)。CSRF 的原理是利用浏览器的 Cookie 或服务器的 Session，盗取用户身份，其原理如 下图所示。防范 CSRF 的主要手段是识别请求者的身份，主要有以下几种方式:	
(1)在表单中添加令牌(token);	
(2)验证码;		
(3)检查请求头中的 Referer(前面提到防图片盗链接也是用的这种方式)。 令牌和验证都具有一次消费性的特征，因此在原理上一致的，但是验证码是一种糟糕的用户体验，不是必要的情况下不要轻易使用验证码，目前很多网站的做法是如果在短时间内多次提交一个表单未获得成功后才要求提供验 证码，这样会获得较好的用户体验。	

#### apache 和 nginx 的区别?

Nginx 相对 Apache 的优点:	
轻量级，同样起 web 服务，比 apache 占用更少的内存及资源;    
抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而 apache 则是阻塞型的，在高并发下 nginx 能保持低资源低消耗高性能;	   
配置简洁; 高度模块化的设计，编写模块相对简单; 社区活跃。   
Apache 相对 Nginx 的优点:     
rewrite ，比 nginx 的 rewrite 强大; 模块超多，基本想到的都可以找到;    
少 bug ，nginx 的 bug 相对较多;   
超稳定。  

**备注：**

```
前端的路上我们一起携手共进！如果转载，请标注本链接地址。
```

​[MIT](https://github.com/famensaodiseng/Front-End/blob/master/LICENSE)	©[杨方涛](https://github.com/famensaodiseng)   		

Email:58267980@qq.com
